


‚úÖ JVM Flags T·ªëi ∆Øu - C√≥ Ghi Ch√∫ & M·ª©c ƒê·ªô Hi·ªáu NƒÉng
Lu√¥n vi·∫øt d·∫°ng: -XX:+<flag> ƒë·ªÉ b·∫≠t
Lu√¥n vi·∫øt d·∫°ng: -XX:+<flag> ƒë·ªÉ b·∫≠t
Flag boolean (true/false) c·∫ßn ƒë√∫ng vi·∫øt hoa, kh√¥ng vi·∫øt th∆∞·ªùng (+UseFMA, kh√¥ng ph·∫£i +usefma)
Khi test: b·∫°n c√≥ th·ªÉ th√™m -XX:+PrintFlagsFinal ƒë·ªÉ ki·ªÉm tra gi√° tr·ªã cu·ªëi ƒë√£ set ch∆∞a


üìå Experimental & Vector API (N√™n b·∫≠t)
-XX:+UnlockExperimentalVMOptions 		# B·∫≠t flag experimental
-XX:+UnlockDiagnosticVMOptions			#B·∫≠t flag g·ª° l·ªói
--add-modules jdk.incubator.vector 		# B·∫≠t Vector API cho code Java

üß† T·ªëi ∆∞u CPU & ƒëa lu·ªìng (R·∫•t n√™n d√πng cho CPU nhi·ªÅu nh√¢n)
-XX:+UseAllWindowsProcessorGroups 		# Cho ph√©p JVM th·∫•y to√†n b·ªô CPU group (Windows)
-XX:ActiveProcessorCount=72 			# √âp JVM d√πng ƒë·ªß s·ªë lu·ªìng d√π h·ªá ƒëi·ªÅu h√†nh kh√¥ng b√°o ƒë√∫ng
-Djdk.virtualThreadScheduler.parallelism=72 	# T·ªëi ∆∞u cho Virtual Thread (Java Loom)
-XX:CICompilerCount=36 				# TƒÉng s·ªë thread bi√™n d·ªãch JIT
-XX:+TieredCompilation 				# D√πng c·∫£ C1 + C2 compiler (m·∫∑c ƒë·ªãnh)
-XX:MaxInlineLevel=15 				# TƒÉng ƒë·ªô s√¢u inline function
-XX:+OptimizeFill 				# D√πng intrinsic memset/memfill thay loop fill (nhanh h∆°n)

üí™ SIMD & Vector Intrinsics ‚Äì R·∫•t li√™n quan AVX2, SSE, FMA3
-XX:UseSSE=4                            # D√πng t·ªëi ƒëa SSE4.2
-XX:+UseAES                             # B·∫≠t tƒÉng t·ªëc AES
-XX:+UseAESIntrinsics                   # D√πng AES-NI
-XX:+UseFMA                             # Fused Multiply-Add (FMA3)
-XX:+UsePopCountInstruction             # TƒÉng t·ªëc bit count
-XX:+UseCRC32Intrinsics                 # D√πng l·ªánh CRC32 (SSE4.2)
-XX:+UseSHA                             # D√πng SHA tƒÉng t·ªëc hash
-XX:+UseSHA256Intrinsics                # SHA-256 ph·∫ßn c·ª©ng (hi·∫øm)
-XX:+UseSHA512Intrinsics                # SHA-512 ph·∫ßn c·ª©ng (hi·∫øm)
-XX:+UseFastCRC32                       # CRC32 hardware nhanh h∆°n
-XX:+UseVectorCmov                      # D√πng conditional move trong vector
-XX:+UseVectorizedMismatchIntrinsic     # So s√°nh vector (Arrays.equals, mismatch‚Ä¶)
-XX:+UseMultiplyToLenIntrinsic          # T·ªëi ∆∞u BigInteger.multiply
-XX:+UseSquareToLenIntrinsic            # T·ªëi ∆∞u BigInteger.square
-XX:+SuperWordLoopUnrollAnalysis        # Ph√¢n t√≠ch unroll cho vector
-XX:+UseSSE42Intrinsics			#G·∫ßn gi·ªëng UseSSE=4 nh∆∞ng √©p r√µ SSE4.2 cho method c·ª• th·ªÉ
-XX:+UseLibmIntrinsic			#Gi·∫£m ƒë·ªô ch√≠nh x√°c nh∆∞ng tƒÉng t·ªëc (d√πng trong game/math engine)


üß† Vector h√≥a n√¢ng cao (TƒÉng hi·ªáu nƒÉng t√≠nh to√°n)
-XX:+EnableVectorSupport 			# B·∫≠t vector h√≥a to√†n JVM
-XX:+EnableVectorReboxing 			# T·ªëi ∆∞u boxing/unboxing khi vector h√≥a
-XX:+EnableVectorAggressiveReboxing 		# √âp vector h√≥a k·ªÉ c·∫£ code ph·ª©c t·∫°p h∆°n
-XX:+UseBasicIntrinsics				#D√πng m·ªôt b·ªô t·∫≠p h·ª£p intrinsic ƒë∆°n gi·∫£n, √≠t ph·ª©c t·∫°p h∆°n C2 
-XX:+UseXmmI2F					#D√πng XMM register ƒë·ªÉ convert Integer to Float, AVX friendly.
-XX:+UseXmmRegToRegMoveAll			#√âp d√πng move register XMM‚ÜíXMM thay v√¨ memory move (tƒÉng SIMD throughput)
-XX:+UseAVX512Intrinsics			#N·∫øu m√°y c√≥ AVX-512, b·∫°n c√≥ th·ªÉ th·ª≠ flag n√†y (ZGC + AVX512).
-XX:+UseVectorUnrollLimit			#Gi√∫p tƒÉng ch√≠nh x√°c vector h√≥a khi k·∫øt h·ª£p unroll loop v·ªõi AVX2, t·ªëi ∆∞u loop vector






üöÄ T·ªëi ∆∞u CPU n√¢ng cao (Hi·∫øm, an to√†n, n√™n test)
-XX:+UseLoopPredicate 				# T·ªëi ∆∞u h√≥a ƒëi·ªÅu ki·ªán v√≤ng l·∫∑p (loop hoisting)
-XX:+UseXmmLoadAndClearUpper 			# Gi·∫£m overhead chuy·ªÉn AVX‚ÜíSSE (t·ªët SIMD native)
-XX:+ReduceBulkZeroing 				# TƒÉng t·ªëc kh·ªüi t·∫°o v√πng nh·ªõ zero (new int[], float[])
-XX:+UseFPUForSpilling 				# D√πng FPU register tr√°nh spill khi register thi·∫øu (CPU-bound)
-XX:+UseFastStosb 				# (Windows) D√πng STOSB thay memset (zeroing block nhanh h∆°n)
-XX:+UseUnalignedAccesses 			# Cho ph√©p truy c·∫≠p kh√¥ng align (ByteBuffer, JNI‚Ä¶)
-XX:+UseNewCode 				# Backend sinh m√£ m√°y m·ªõi c·ªßa C2 (experimental)
-XX:AzMemPartition=0 				# G√°n heap v√†o NUMA partition 0 (socket ƒë·∫ßu)
-XX:UseAVX					#S·ª≠ dung AVX c√≥ th·ªÉ g√°n -XX:UseAVX=0 1 2 3
-XX:+UseCRC32Intrinsics				#B·∫≠t s·ª≠ d·ª•ng l·ªánh ph·∫ßn c·ª©ng CRC32 ƒë·ªÉ tƒÉng t·ªëc t√≠nh to√°n CRC32
-XX:+UseCMoveUnconditionally			#Lu√¥n √©p d√πng cmov
-XX:LoopMaxUnroll=16				#T·ªëi ∆∞u AVX, FMA
-XX:+TrustFinalNonStaticFields			#Tin t∆∞·ªüng final field kh√¥ng ƒë·ªïi
-XX:AllocatePrefetchLines=4			#s·ªë cache line prefetch
-XX:AllocatePrefetchStepSize=64 		#ƒëi·ªÅu ch·ªânh b∆∞·ªõc prefetch
-XX:+UseNUMAChunkAwareMemoryAllocation		#B·ªï sung th√™m cho NUMA, gi√∫p c·∫£i thi·ªán vi·ªác ph√¢n b·ªï b·ªô nh·ªõ theo chunk
-XX:+UseBiasedLocking / -XX:-UseBiasedLocking	#T√πy app, ƒë√¥i khi t·∫Øt b·∫≠t c√°i n√†y gi√∫p c·∫£i thi·ªán lock performance.
-XX:InlineSmallCodeCount=XXX			#Ch·ªânh s·ªë l∆∞·ª£ng h√†m nh·ªè ƒë∆∞·ª£c inline, c√≥ th·ªÉ ch·ªânh InlineSmallCode.
-XX:+UseJVMCICompiler				#K√≠ch ho·∫°t JVMCI n·∫øu b·∫°n mu·ªën d√πng Graal ho·∫∑c compiler b√™n ngo√†i.
-XX:+UseCondCardMark				#C·∫£i thi·ªán hi·ªáu qu·∫£ write barrier trong GC.
-XX:+UseSuperWord				#C·ªù d√πng ƒë·ªÉ t·ªëi ∆∞u v√≤ng l·∫∑p vector h√≥a trong JIT.
-XX:+UseRTM					#N·∫øu CPU h·ªó tr·ª£ Intel TSX, flag n√†y c√≥ th·ªÉ tƒÉng hi·ªáu nƒÉng lock-free.
-XX:+UseLargePagesIndividualAllocation		#T·ªëi ∆∞u cho h·ªá th·ªëng NUMA nhi·ªÅu RAM.
-XX:+UseTransparentHugePages			#Cho ph√©p JVM t·∫≠n d·ª•ng transparent hugepages t·ª´ kernel Linux
-XX:+UseCodeCacheFlushing			#Cho ph√©p flush code cache JIT n·∫øu ƒë·∫ßy.
-XX:+UseSpinLoopHint				#Gi√∫p hint spinlock b·∫±ng l·ªánh PAUSE tr√™n x86, c√≥ th·ªÉ gi√∫p reduce render/update
-XX:+UseVzeroupper				#Ch√®n l·ªánh vzeroupper ƒë·ªÉ tr√°nh AVX-SSE transition penalty tr√™n CPU AVX2
-XX:+UseLWPSynchronization			#D√πng Lightweight Primitive Synchronization (tr√™n Linux, h·ªó tr·ª£ futex-based lock).
-XX:+UseCrc32cIntrinsics			#D√πng CRC32C thay v√¨ CRC32 th√¥ng th∆∞·ªùng, c√≥ l·ª£i netty, code c√≥ checksum t·ªëc ƒë·ªô cao
-XX:+UseFastJNIAccessors			#TƒÉng t·ªëc JNI accessor methods (GetObjectField, SetIntField, v.v.) 
-XX:+UseFastArrayMethods			#D√πng b·∫£n optimized (th∆∞·ªùng l√† SIMD) cho c√°c System.arraycopy, Arrays.fill,...
-XX:+UseVectorizedHashCode			#SIMD tƒÉng t·ªëc Arrays.hashCode() (√≠t ƒë∆∞·ª£c bi·∫øt).
-XX:+UseFMAIntrinsics				#B·∫°n ƒë√£ c√≥ -XX:+UseFMA r·ªìi, nh∆∞ng tr√™n Zulu c√≥ l√∫c split ra ri√™ng trong PrintFlags.
-XX:+UseXmmLoadAndClearUpper			#Gi·∫£m AVX-SSE penalty
-XX:+UseCLMUL					#D√πng CLMUL ‚Äì b·∫°n c√≥ l·ªánh n√†y
-XX:+UseCountLeadingZerosInstruction  		#LZCNT n·∫øu CPU c√≥
-XX:+UseCountTrailingZerosInstruction		#TZCNT n·∫øu CPU c√≥
-XX:+UseOnlyInlinedBimorphic			#Inline method d·∫°ng bimorphic
-XX:+UseDynamicNumberOfCompilerThreads		#Scale thread compile
-XX:+UseLoopInvariantCodeMotion			#Loop hoisting s√¢u







üñ•Ô∏è Windows system-level tuning (Hi·∫øm, gi·∫£m jitter, tƒÉng ch√≠nh x√°c)
-XX:+UseThreadPriorities 			# JVM d√πng native priority c·ªßa thread
-XX:+UseHighResolutionTimer 			# Timer ƒë·ªô ph√¢n gi·∫£i cao, gi·∫£m jitter latency
-XX:+UsePreciseTimeStamps 			# TƒÉng ƒë·ªô ch√≠nh x√°c th·ªùi gian tr√™n Windows
-XX:+UseAltSigs 				# Signal handler ki·ªÉu alternative (hi·∫øm d√πng)
-XX:PreBlockSpin=10 				# Spin 10 v√≤ng tr∆∞·ªõc context switch khi ch·ªù lock

üß™ Deep tuning (Hi·∫øm, d√πng c·∫©n tr·ªçng cho benchmark ho·∫∑c mod native)
-XX:+UseVectorCmov 				# D√πng conditional move thay if branch SIMD
-XX:+AggressiveUnboxing				# √âp JVM b·ªè boxing s·ªõm (test k·ªπ tr∆∞·ªõc khi b·∫≠t)
-XX:+UseCountedLoopSafepoints 			# Safepoint trong loop ch√≠nh x√°c (debug native nhi·ªÅu thread)

üíæ RAM t·ªëi ∆∞u & c·∫•p ph√°t hi·∫øm (C·∫©n tr·ªçng, benchmark k·ªπ)
-XX:+UseTransparentHugePages 			# (Linux) D√πng Transparent HugePages t·ª± ƒë·ªông
-XX:+UseTLAB					#S·ª≠ d·ª•ng TLAB
-XX:+UseLargePages 				# K√≠ch ho·∫°t Large Pages 2MB (Windows c·∫ßn quy·ªÅn lock memory)
-XX:LargePageSizeInBytes=2m			# C·ª• th·ªÉ k√≠ch th∆∞·ªõc trang l·ªõn = 2MB
-XX:PretenureSizeThreshold=16m 			# Object >16MB t·∫°o th·∫≥ng OldGen (gi·∫£m copy GC)
-XX:TLABSize=2m 				# B·ªô nh·ªõ per thread (Thread Local Allocation Buffer)
-XX:MaxTLABSize=4m 				# Gi·ªõi h·∫°n t·ªëi ƒëa TLAB size (tr√°nh tr√†n RAM)
-XX:+ResizeTLAB 				# Cho ph√©p JVM t·ª± ƒëi·ªÅu ch·ªânh TLAB theo t·∫£i
-XX:SurvivorRatio=8 				# ƒêi·ªÅu ch·ªânh t·ª∑ l·ªá Eden:Survivor (benchmark n·∫øu object churn cao)
-XX:+AlwaysPreTouch 				# Ch·∫°m to√†n b·ªô heap tr∆∞·ªõc khi ch·∫°y (gi·∫£m lag n·∫øu Xmx l·ªõn)
-XX:+UseNUMAChunkInterleaving 			# T·∫Øt interleave chunk n·∫øu c·ªë ƒë·ªãnh lu·ªìng NUMA (advanced)
-XX:+UseCompressedOops				#T·ªëi ∆∞u n√©n pointer v·ªõi ram t·ª´ 32Gb tr·ªü xu·ªëng
-XX:AllocatePrefetchDistance=192 		# Prefetch memory t·ªët h∆°n khi load chunk / rebuild mesh
-XX:+UseStringConcatOverflowCheck		#Gi√∫p tr√°nh l·ªói tr√†n b·ªô nh·ªõ trong concat string
-XX:+UseStringCache				#Gi√∫p caching c√°c chu·ªói string n·ªôi b·ªô, ƒë·∫∑c bi·ªát v·ªõi workload nhi·ªÅu String reuse.
-XX:+UseStrongUnorderedTimeStamps		#Thay th·∫ø UseFastUnorderedTimeStamps ƒë·ªÉ c√¢n b·∫±ng ƒë·ªô ch√≠nh x√°c v√† t·ªëc ƒë·ªô timestamp.
-XX:+UseNUMAChunkPinning			#C·ªë ƒë·ªãnh chunk b·ªô nh·ªõ theo NUMA node, t·ªëi ∆∞u h∆°n khi d√πng NUMA ph·ª©c t·∫°p.
-XX:+UseOnStackReplacement			#Cho ph√©p thay th·∫ø code t·∫°i ch·ªó khi ƒëang ch·∫°y, gi·∫£m overhead cho c√°c loop.
-XX:+UseStringUTF16				#Khi ·ª©ng d·ª•ng b·∫°n d√πng nhi·ªÅu String UTF-16, gi·∫£m b·ªô nh·ªõ v√† tƒÉng hi·ªáu nƒÉng string.
-XX:LoopUnrollLimit=256				#Gi·ªõi h·∫°n unroll loop r·ªông h∆°n c√≥ th·ªÉ tƒÉng hi·ªáu nƒÉng loop n·∫∑ng.
-XX:+UseXmmSaveRestore				#C√≥ th·ªÉ c·∫£i thi·ªán hi·ªáu su·∫•t save/restore SIMD register tr√™n m·ªôt s·ªë CPU.
-XX:+UseTLABFastRefills				#TƒÉng t·ªëc allocation trong TLAB khi refilling nhanh.
-XX:+UseMembar					#K√≠ch ho·∫°t memory barrier d√πng trong m·ªôt s·ªë ki·∫øn tr√∫c CPU ƒë·∫∑c bi·ªát.
-XX:+AlwaysActAsServerClassMachine		#Lu√¥n ch·∫°y ch·∫ø ƒë·ªô Server VM tuning, ngay c·∫£ n·∫øu m√°y b·ªã detect nh·∫ßm l√† client-class.
-XX:+UseNUMAChunkAllocation			#M·ªôt s·ªë b·∫£n Zulu 21 h·ªó tr·ª£ th·ª≠ nghi·ªám NUMA chunk pinning/allocation
-XX:+UseAdaptiveNUMAChunkSizing			#C·ªë g·∫Øng c√¢n b·∫±ng k√≠ch th∆∞·ªõc chunk tr√™n c√°c NUMA node.
-XX:+UseBiasedLocking				#Lock nh·∫π h∆°n x√≥a ·ªü jdk-15, nh∆∞ng Zulu c√≥ th·ªÉ v·∫´n gi·ªØ l·∫°i backwards compatibility.
-XX:+UseLocalPrefetch				#D√πng local prefetch logic khi load d·ªØ li·ªáu v√†o cache
-XX:+ZUncommitRelocationSet			#Cho ph√©p d·ªçn b·ªõt b·ªô nh·ªõ relocation trong ZGC gi·∫£m RAM nh∆∞ng latency c√≥ th·ªÉ tƒÉng nh·∫π
-XX:+UseTLSCHotSpotCache			#C·∫£i thi·ªán truy c·∫≠p TLS
-XX:ReservedCodeCacheSize=512m			#TƒÉng code cache ƒë·ªÉ tr√°nh vi·ªác JVM ph·∫£i d·ªçn d·∫πp code cache g√¢y lag trong runtime.
-XX:+UseSpinWait				#Gi√∫p thread ƒë·ª£i spin hi·ªáu qu·∫£ h∆°n, c√≥ th·ªÉ gi·∫£m ƒë·ªô tr·ªÖ thread switching.




üìÇ I/O t·ªëi ∆∞u & debug (Hi·∫øm, t√πy OS)
-Djdk.nio.maxCachedBufferSize=1048576				# Cache DirectBuffer t·ªëi ƒëa 1MB
-Dsun.zip.disableMemoryMapping=true				# T·∫Øt mmap ƒë·ªçc zip/jar (fix crash modpack n·∫∑ng)
-Djdk.io.File.enableADS=false 					# (Windows) T·∫Øt NTFS Alternate Data Streams ‚Üí IO nhanh h∆°n
-Djdk.util.zip.disableZip64ExtraFieldValidation=true 		# ƒê·ªçc zip kh√¥ng chu·∫©n, tr√°nh crash
-Djdk.nio.enableFastFileTransfer=true		 		# (Linux/macOS) D√πng sendfile() khi copy file


üõ† Profiling & debug native (Hi·∫øm, ch·ªâ b·∫≠t khi c·∫ßn)
-XX:+PreserveFramePointer 			# Gi·ªØ frame pointer ƒë·ªÉ profiler native stacktrace ch√≠nh x√°c
-XX:+StackTraceInThrowable 			# TƒÉng chi ti·∫øt stacktrace khi throw (gi√∫p debug mod)
-Dprism.forceGPU=true				#√âp JavaFX ch·∫°y GPU thay v√¨ CPU fallback
-Dprism.vsync=false				#T·∫Øt ƒë·ªìng b·ªô V-Sync, c√≥ th·ªÉ tƒÉng FPS (c√≥ th·ªÉ g√¢y tearing)

üî• TSX, BMI, Advanced SIMD (‚ö†Ô∏è R·∫•t hi·∫øm, c·∫ßn m√°y h·ªó tr·ª£)
-XX:+UseRTMLocking                      # D√πng TSX/RTM n·∫øu CPU h·ªó tr·ª£ (Haswell+)
-XX:+UseRTMDeopt                        # T·ª± ƒë·ªông fallback n·∫øu TSX fail
-XX:+UseBMI1Instructions                # BMI1: andn, tzcnt (C·∫ßn JVM ƒë·∫∑c bi·ªát)
-XX:+UseBMI2Instructions                # BMI2: pext, pdep (hi·∫øm, nh∆∞ tr√™n)
-XX:+EliminateLocks                     # B·ªè c√°c lock kh√¥ng c·∫ßn thi·∫øt
-XX:+UseVectorizedHashCode		#SIMD h√≥a String.hashCode()
-XX:+UseXmmRegToRegMoveAll		#XMM move register-only
-XX:+EnableJVMCI			#K√≠ch ho·∫°t JVMCI n·∫øu kh√¥ng m·∫∑c ƒë·ªãnh b·∫≠t.





üóÇ Heap & GC n√¢ng cao (Hi·∫øm, gi√∫p ·ªïn ƒë·ªãnh h∆°n)
-XX:MinHeapFreeRatio=20 			# Gi·ªØ t·ªëi thi·ªÉu 20% heap free (gi·∫£m freq GC ƒë·ªôt ng·ªôt)
-XX:MaxHeapFreeRatio=40 			# Thu heap khi s·ª≠ d·ª•ng <60%
-XX:+HeapDumpOnOutOfMemoryError 		# T·ª± ƒë·ªông dump heap khi OOM (debug memory leak)
-XX:+UseRTMForStackLock				# S·ª≠ d·ª•ng RTM cho stack locks (nh·∫π h∆°n object monitor)
-XX:RTMRetryCount=5				# S·ªë l·∫ßn retry khi RTM th·∫•t b·∫°i
-XX:+UseSimpleArrayEquals			#N·∫øu b·∫≠t, c√°c Arrays.equals() d√πng phi√™n b·∫£n ƒë∆°n gi·∫£n h√≥a
-XX:+UseTypeProfileInlining			#D√πng profiling ki·ªÉu object ƒë·ªÉ inline t·ªët h∆°n c√°c method generic/abstract.
-XX:+TraceSuperWord				#Theo d√µi h√†nh vi SuperWord ƒë·ªÉ debug SIMD kh√¥ng auto vectorize
-XX:+UseOnlyInlinedBCE				#B·ªè bounds check elimination cho c√°c method ch∆∞a ƒë∆∞·ª£c inline
-XX:+EagerJVMCI					#JVMCI ƒë∆∞·ª£c init s·ªõm h∆°n, gi·∫£m latency kh·ªüi ƒë·∫ßu.




üîß Native & JNI tuning (Hi·∫øm, hi·ªáu nƒÉng cao)
-XX:-UseBiasedLocking 				# T·∫Øt biased locking ‚Üí gi·∫£m overhead lock/unlock nhi·ªÅu l·∫ßn
-XX:+UseNUMAChunkInterleaving 			# Ph√¢n ph·ªëi memory t·ªët h∆°n tr√™n h·ªá NUMA (multi-socket)
-XX:InlineSmallCode=1000			#TƒÉng ng∆∞·ª°ng inline code nh·ªè, gi√∫p JIT t·ªëi ∆∞u t·ªët h∆°n.
-XX:+OptimizeStringConcat	#T·ªëi ∆∞u n·ªëi chu·ªói, h·ªØu √≠ch khi c√≥ nhi·ªÅu thao t√°c string li√™n quan ƒë·∫øn chunk data.
-XX:+UseJNICriticalNatives			#Zero-copy JNI, crash n·∫øu sai
-XX:+UseClMulIntrinsics				#D√πng carry-less multiply (CLMUL)
-XX:+EnableContended -XX:-RestrictContended 	#T·ªëi ∆∞u cho c√°c tr∆∞·ªùng @Contended trong Java ƒë·ªÉ tr√°nh false sharing
-XX:+StressLCM					#Kh√¥ng n√™n d√πng l√¢u d√†i, h·ªØu √≠ch ƒë·ªÉ debug bottleneck trong hot loop
-XX:+StressGCM					#Test th·ª≠ t·∫•t c·∫£ l·ª±a ch·ªçn,√©p code gen sinh m√£ t·ªëi ƒëa ƒë·ªÉ t√¨m l·ªói ho·∫∑c leak hi·ªáu nƒÉng.
-XX:+UseVectorStubs				# Cho ph√©p d√πng native stub cho vector operation chx ƒëc intrinsified.
-XX:+UseSuperWordLoopUnrollAnalysis		# +UseSuperWord (c√≥ th·ªÉ b·ªã xung ƒë·ªôt n·∫øu build kh√¥ng h·ªó tr·ª£ c·∫£ hai r√µ r√†ng)


üóëÔ∏è T·ªëi ∆∞u GC
-XX:+UseShenandoahGC				#N·∫øu b·∫°n mu·ªën th·ª≠ GC kh√°c ngo√†i ZGC, nh∆∞ng ZGC v·∫´n l√† t·ªëi ∆∞u
-XX:+UseEpsilonGC				#N·∫øu b·∫°n mu·ªën th·ª≠ GC kh√°c ngo√†i ZGC, nh∆∞ng ZGC v·∫´n l√† t·ªëi ∆∞u
-XX:+ShenandoahUncommit				#T·ª± ƒë·ªông b·ªè page RAM kh√¥ng d√πng (Shenandoah only).
-XX:+ShenandoahHumongousMoves			#T·ªëi ∆∞u copy object l·ªõn trong Shenandoah.
-XX:+ShenandoahRegionSampling			#B·∫≠t th·ªëng k√™ v√πng heap khi GC (debug performance).
-XX:+DisableExplicitGCOnSystemGC		#NgƒÉn System.gc() t·ª´ ch√≠nh JVM (Java 17+).



üóëÔ∏è T·ªëi ∆∞u ZGC (Low latency GC cho RAM l·ªõn)
-XX:+UseZGC 					# B·∫≠t Z Garbage Collector
-XX:ZUncommitDelay=10000 			# Delay unmap page ch∆∞a d√πng l·∫°i (ms)
-XX:ZCollectionInterval=128 			# Kho·∫£ng c√°ch 2 l·∫ßn ch·∫°y ZGC
-XX:+ZProactive 				# Thu gom r√°c ch·ªß ƒë·ªông
-XX:+UseStringDeduplication 			# Gi·∫£m tr√πng chu·ªói trong memory
-XX:SoftMaxHeapSize=140G 			# Gi·ªõi h·∫°n "m·ªÅm" heap tr√°nh GC l·ªõn ƒë·ªôt ng·ªôt
-XX:+UseZStore					# Gi√∫p n√©n d·ªØ li·ªáu trong ZGC, ti·∫øt ki·ªám b·ªô nh·ªõ nhi·ªÅu h∆°n.
-XX:ParallelGCThreads=1				# Ch·ªâ ƒë·ªãnh s·ªë lu·ªìng GC c√≥ th·ªÉ t·ªët h∆°n trong m·ªôt s·ªë tr∆∞·ªùng h·ª£p
-XX:+ZGenerational				#(Zulu 21+ c√≥ th·ªÉ th·ª≠) B·∫≠t ch·∫ø ƒë·ªô ZGC th·∫ø h·ªá ‚Äì h·ªó tr·ª£ Eden + Old Gen.


üõ†Ô∏è T·ªëi ∆∞u th·ªùi gian h·ªá & locking
-XX:+UseFastUnorderedTimeStamps 		# D√πng RDTSC l·∫•y th·ªùi gian nhanh h∆°n
-XX:LockingMode=0 				# D√πng Thin Locking (kh√¥ng biased lock)

üß™ GC h·ªó tr·ª£ tham chi·∫øu song song
-XX:+ParallelRefProcEnabled 			# X·ª≠ l√Ω Reference song song (WeakRef, Finalizer...)

üö´ V√¥ hi·ªáu h√≥a GC ngo√†i √Ω mu·ªën & Graal
-XX:+DisableExplicitGC 				# Ch·∫∑n System.gc() t·ª´ mod b√™n th·ª© 3
-XX:-UseGraalJIT 				# T·∫Øt Graal n·∫øu b·∫°n mu·ªën √©p JVM d√πng C2 truy·ªÅn th·ªëng

üìä Ghi log & theo d√µi hi·ªáu nƒÉng
-Xlog:gc*,safepoint:file=gc.log:tags,uptime,time,level 	# Ghi log GC v√† d·ª´ng m√°y
-XX:+PrintCompilation 					# Hi·ªÉn th·ªã log khi JIT compile method n√†o
-XX:+PrintFlagsFinal					# Ghi to√†n b·ªô flags th·ª±c t·∫ø JVM s·ª≠ d·ª•ng, ƒë·ªÉ log/debug
-XX:+HeapDumpOnOutOfMemoryError				# Dump heap n·∫øu crash OOM ‚Äì debug mod d·ªÖ h∆°n
-XX:+PrintInlining					# Mu·ªën theo d√µi inline method n√†o khi JIT?
-XX:+PerfDisableSharedMem				# C√≥ th·ªÉ th·ª≠ n·∫øu kh√¥ng d√πng c√°c tool monitoring d√πng PerfData
-XX:+UnlockJavaMonitoringAndManagement
-XX:+PrintAssembly
-XX:+TraceLinearScanLevel				#Log n·ªôi b·ªô b·ªô ph√¢n register allocator LinearScan.
-XX:+PrintCFGToFile					#Xu·∫•t control flow graph ƒë·ªÉ debug JIT code gen.
-XX:+PrintOptoAssembly				#In c·∫£ m√£ m√°y t·ªëi ∆∞u c·ªßa C2 ‚Äì c·ª±c n·∫∑ng, nh∆∞ng c·ª±c k·ª≥ chi ti·∫øt.
-XX:+PrintIRWithLIRGraphs			#N·∫øu test Graal, in IR trung gian.
-XX:+TraceDeoptimization			#Log khi m·ªôt method b·ªã deoptimize ‚Üí r·∫•t quan tr·ªçng n·∫øu c√≥ native agent can thi·ªáp
-XX:+LogCompilation				#Output XML file to√†n b·ªô h√†nh vi JIT + compile graph.
-XX:+TraceOSR					#N·∫øu b·∫°n ƒëang benchmark loop n√†o b·ªã OSR (On Stack Replacement).
-XX:+PrintInliningDetailed			#B·∫£n chi ti·∫øt h∆°n -XX:+PrintInlining.


‚öôÔ∏è Fix & config c√°c l·ªói Minecraft mod
-Dfml.ignoreInvalidMinecraftCertificates=true 			# Forge fix l·ªói ch·ª©ng ch·ªâ
-Dfml.ignorePatchDiscrepancies=true 				# B·ªè qua ch√™nh l·ªách patch Forge
-Djava.net.preferIPv4Stack=true 				# D√πng IPv4 thay IPv6 (·ªïn ƒë·ªãnh h∆°n)
-XX:-EnableDynamicAgentLoading 					# T·∫Øt cho ph√©p agent runtime n·∫øu kh√¥ng c·∫ßn
-javaagent:D:\Agent\multicpu_agent.jar 				# Agent ƒëa lu·ªìng t√πy bi·∫øn b·∫°n vi·∫øt
-Djava.util.concurrent.ForkJoinPool.common.parallelism=72	#T·ªëi ∆∞u parallelism n·∫øu modpack d√πng ForkJoin
-Dio.netty.recycler.maxCapacityPerThread=0			#T·∫Øt cache Netty n·∫øu b·ªã memory leak do mod network
-Dgraal.ExplicitUnsafe=true					#T·ªëi ∆∞u truy c·∫≠p Unsafe, khi vi·∫øt mod ho·∫∑c agent native.
-Dgraal.CompileThreads=24					#T·ªëi ∆∞u thread bi√™n d·ªãch cho GraalVM n·∫øu c√≥ th·ª≠.



üî¨ 2. GraalVM / JVMCI-specific Flag (n·∫øu b·∫°n test Graal ho·∫∑c b·∫≠t -XX:+EnableJVMCI)
-Dgraal.UseSVE=true			#D√†nh cho ARMv8 SVE (n·∫øu b·∫°n test native vector JIT future).
-Dgraal.OptMacroFusion=true		#T·ªëi ∆∞u instruction fusion trong JIT (Graal).
-Dgraal.OptAvoidSpeculation=true	#Tr√°nh speculative branch trong code JIT ‚Äì gi·∫£m overhead multi-core render.
-XX:+JVMCIPrintProperties		#Li·ªát k√™ to√†n b·ªô option m√† JVMCI/Graal c√≥ th·ªÉ d√πng.



üß∞ Nh·ªØng flag "kh√¥ng flags" ‚Äì nh∆∞ng ƒë√°ng test th√™m:
-Xbatch 				#T·∫Øt ch·∫ø ƒë·ªô bi√™n d·ªãch n·ªÅn, compile ngay (d√πng ƒë·ªÉ benchmark ch√≠nh x√°c JIT).
-Xcomp 					#Compile to√†n b·ªô code, kh√¥ng d√πng interpreter (benchmark hotpath).
-Xverify:none 				#T·∫Øt bytecode verifier ‚Üí gi·∫£m startup time.
-XX:+UseStringLatin1 			#D√πng compact String UTF8-Latin1 (gi·∫£m RAM n·∫øu chu·ªói kh√¥ng c√≥ k√Ω t·ª± Unicode cao).




üîß C·ªï ƒëi·ªÉn & kh√¥ng c√≤n ph·ªï bi·∫øn, nh∆∞ng v·∫´n note l·∫°i cho ƒë·∫ßy ƒë·ªß
# Kh√¥ng c√≤n hi·ªáu l·ª±c, nh∆∞ng b·∫°n ghi ch√∫ ƒë·ªÉ tra c·ª©u n·∫øu mu·ªën th·ª≠ JVM c·ªï
-XX:+UseMMX                             # (JVM c≈©, kh√¥ng c√≤n h·ªó tr·ª£ sau Java 6)
-XX:+Use3DNOW                           # (AMD only, obsolete)
-XX:+UseVTune                           # (Intel VTune integration)
-XX:+UseG1GC                            # D√πng GC m·ªõi h∆°n ZGC
-XX:+UseBiasedLocking                   # Biased lock (ƒë√£ b·ªã x√≥a kh·ªèi JDK 17+)

‚öôÔ∏è 1. Flag Hi·∫øm C·ª±c ƒê·ªô ‚Äì Th∆∞·ªùng kh√¥ng c√≥ trong PrintFlagsFinal
-XX:+UseFastEmptyMethods		#TƒÉng t·ªëc c√°c method tr·ªëng (r·∫•t nh·∫π, nh∆∞ng c√≥ l·ª£i n·∫øu mod c√≥ nhi·ªÅu stub/trampoline method).
-XX:+UseFastClassInitChecks		#T·ªëi ∆∞u ki·ªÉm tra kh·ªüi t·∫°o class (ƒë·∫∑c bi·ªát class static-heavy).
-XX:+UseThreadCpuClocks			#D√πng ƒë·ªìng h·ªì CPU thay v√¨ wall-clock (gi·∫£m jitter profiling, test JVM x√°c ƒë·ªãnh bottleneck)
-XX:+EnableVectorUnrollLimit		#Gi√∫p vector h√≥a ch√≠nh x√°c h∆°n khi k·∫øt h·ª£p unroll loop + AVX2 (t√πy JVM build m·ªõi).
-XX:+UseSIMDForArrayCopy		#T·ªëi ∆∞u System.arraycopy() d√πng SIMD thay memcpy (r·∫•t hi·∫øm th·∫•y b·∫≠t s·∫µn).
-XX:+UseMicroLocking			#N·∫øu d√πng nhi·ªÅu lock nh·ªè (nh∆∞ lock t·ª´ng chunk ho·∫∑c thread-local), flag n√†y c·ª±c k·ª≥ h·ªØu √≠ch.
-XX:+InlineNotifyWait			#Inline ph·∫ßn th√¢n wait/notify n·∫øu c√≥ th·ªÉ ‚Äì c·ª±c hi·∫øm d√πng nh∆∞ng gi·∫£m context switch.



üì¶ B·ªô nh·ªõ t·ªëi ƒëa JVM
-Xmx151G 					# C·∫•p t·ªëi ƒëa b·ªô nh·ªõ heap (t∆∞∆°ng th√≠ch ZGC + LargePage)


‚úÖ M·∫´u g·ª£i  t√¥i  ki·ªÉm tra ch∆°i t·∫£i chunk m∆∞·ª£t
T√¥i d√πng Zulu 21.42.19 (21.0.7)
OS: WIndows 11 Pro for Workstation
Progressor 2xE5 2699v3(Unlock Turbo)
Ram: 160GB DDR4 32Gb ECC (3x 2DRx4 and 2x 4Rx4) Skhynix 
GTX 1660
PSU VSP 1000W 

-Xmx151G -XX:+UnlockExperimentalVMOptions --add-modules jdk.incubator.vector -XX:+UseAllWindowsProcessorGroups -XX:ActiveProcessorCount=72 -Djdk.virtualThreadScheduler.parallelism=72 -XX:CICompilerCount=36 -XX:+TieredCompilation -XX:MaxInlineLevel=15 -XX:+OptimizeFill -XX:+EnableVectorSupport -XX:+EnableVectorReboxing -XX:+EnableVectorAggressiveReboxing -XX:+UseTLAB -XX:+AlwaysPreTouch -XX:+UseLargePages -XX:LargePageSizeInBytes=2m -XX:+UseCompressedOops -XX:+UseCompressedClassPointers -XX:+UseAES -XX:UseSSE=4 -XX:+UseZGC -XX:ZUncommitDelay=10000 -XX:ZCollectionInterval=128 -XX:+ZProactive -XX:+UseStringDeduplication -XX:SoftMaxHeapSize=140G -XX:+UseFastUnorderedTimeStamps -XX:LockingMode=0 -XX:+ParallelRefProcEnabled -XX:+DisableExplicitGC -XX:-UseGraalJIT -Dfml.ignoreInvalidMinecraftCertificates=true -Dfml.ignorePatchDiscrepancies=true -Djava.net.preferIPv4Stack=true -XX:-EnableDynamicAgentLoading -XX:+UseNUMA -XX:+UseNUMAInterleaving -javaagent:D:\\Agent\\multicpu_agent.jar -XX:+UseXmmLoadAndClearUpper -XX:+UseLoopPredicate -XX:+ReduceBulkZeroing -XX:+UseFPUForSpilling -XX:+UseFastStosb -XX:+UseCountedLoopSafepoints -XX:+ResizeTLAB -Dsun.zip.disableMemoryMapping=true -Djdk.io.File.enableADS=false -XX:+UseThreadPriorities -Dprism.vsync=false -XX:ThreadPriorityPolicy=1 -XX:CompileThreshold=1500 --enable-preview -XX:+UnlockDiagnosticVMOptions -XX:+UseAESIntrinsics -XX:+UseFMA -XX:+OptimizeStringConcat -XX:InlineSmallCode=900 -XX:+AggressiveUnboxing -XX:+SuperWordLoopUnrollAnalysis -XX:+UseSHA -XX:+UseCRC32Intrinsics -XX:+UsePopCountInstruction -XX:UseAVX=2 -XX:+EliminateLocks -XX:+UseBMI1Instructions -XX:+UseBMI2Instructions -XX:+UseVectorizedMismatchIntrinsic -XX:+UseMultiplyToLenIntrinsic -XX:+UseSquareToLenIntrinsic -XX:+UseLibmIntrinsic -XX:+UseSHA256Intrinsics -XX:+UseSSE42Intrinsics -XX:+UseSHA512Intrinsics -XX:AllocatePrefetchDistance=256 -XX:+PreserveFramePointer -XX:LoopMaxUnroll=32 -XX:AllocatePrefetchLines=3 -XX:AllocatePrefetchStepSize=4 -XX:+UseCondCardMark -XX:+UseSuperWord -XX:+UseCMoveUnconditionally -XX:+UseUnalignedAccesses -XX:+UseVectorCmov -XX:+UseLargePagesIndividualAllocation -XX:+UseCodeCacheFlushing -XX:+EnableContended -XX:-RestrictContended -XX:+UseVectorStubs -XX:+UseOnStackReplacement -XX:LoopUnrollLimit=256 -XX:+UseFastJNIAccessors -XX:+AlwaysActAsServerClassMachine -XX:+UseAdaptiveNUMAChunkSizing -XX:TLABSize=712k -XX:ReservedCodeCacheSize=512m -XX:+UseXmmI2F -XX:+UseXmmRegToRegMoveAll -XX:+ZGenerational -Xverify:none -XX:+UseXmmLoadAndClearUpper -XX:+UseCLMUL -XX:+UseCountLeadingZerosInstruction -XX:+UseCountTrailingZerosInstruction -XX:+UseOnlyInlinedBimorphic -XX:+UseDynamicNumberOfCompilerThreads -XX:+UseLoopInvariantCodeMotion

